{
  "version": 3,
  "sources": ["../../.pnpm/js-binary-schema-parser@2.0.3/node_modules/js-binary-schema-parser/lib/index.js", "../../.pnpm/js-binary-schema-parser@2.0.3/node_modules/js-binary-schema-parser/lib/parsers/uint8.js", "../../.pnpm/js-binary-schema-parser@2.0.3/node_modules/js-binary-schema-parser/lib/schemas/gif.js", "../../.pnpm/gifuct-js@2.1.2/node_modules/gifuct-js/lib/deinterlace.js", "../../.pnpm/gifuct-js@2.1.2/node_modules/gifuct-js/lib/lzw.js", "../../.pnpm/gifuct-js@2.1.2/node_modules/gifuct-js/lib/index.js"],
  "sourcesContent": ["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loop = exports.conditional = exports.parse = void 0;\n\nvar parse = function parse(stream, schema) {\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;\n\n  if (Array.isArray(schema)) {\n    schema.forEach(function (partSchema) {\n      return parse(stream, partSchema, result, parent);\n    });\n  } else if (typeof schema === 'function') {\n    schema(stream, result, parent, parse);\n  } else {\n    var key = Object.keys(schema)[0];\n\n    if (Array.isArray(schema[key])) {\n      parent[key] = {};\n      parse(stream, schema[key], result, parent[key]);\n    } else {\n      parent[key] = schema[key](stream, result, parent, parse);\n    }\n  }\n\n  return result;\n};\n\nexports.parse = parse;\n\nvar conditional = function conditional(schema, conditionFunc) {\n  return function (stream, result, parent, parse) {\n    if (conditionFunc(stream, result, parent)) {\n      parse(stream, schema, result, parent);\n    }\n  };\n};\n\nexports.conditional = conditional;\n\nvar loop = function loop(schema, continueFunc) {\n  return function (stream, result, parent, parse) {\n    var arr = [];\n    var lastStreamPos = stream.pos;\n\n    while (continueFunc(stream, result, parent)) {\n      var newParent = {};\n      parse(stream, schema, result, newParent); // cases when whole file is parsed but no termination is there and stream position is not getting updated as well\n      // it falls into infinite recursion, null check to avoid the same\n\n      if (stream.pos === lastStreamPos) {\n        break;\n      }\n\n      lastStreamPos = stream.pos;\n      arr.push(newParent);\n    }\n\n    return arr;\n  };\n};\n\nexports.loop = loop;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBits = exports.readArray = exports.readUnsigned = exports.readString = exports.peekBytes = exports.readBytes = exports.peekByte = exports.readByte = exports.buildStream = void 0;\n\n// Default stream and parsers for Uint8TypedArray data type\nvar buildStream = function buildStream(uint8Data) {\n  return {\n    data: uint8Data,\n    pos: 0\n  };\n};\n\nexports.buildStream = buildStream;\n\nvar readByte = function readByte() {\n  return function (stream) {\n    return stream.data[stream.pos++];\n  };\n};\n\nexports.readByte = readByte;\n\nvar peekByte = function peekByte() {\n  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return function (stream) {\n    return stream.data[stream.pos + offset];\n  };\n};\n\nexports.peekByte = peekByte;\n\nvar readBytes = function readBytes(length) {\n  return function (stream) {\n    return stream.data.subarray(stream.pos, stream.pos += length);\n  };\n};\n\nexports.readBytes = readBytes;\n\nvar peekBytes = function peekBytes(length) {\n  return function (stream) {\n    return stream.data.subarray(stream.pos, stream.pos + length);\n  };\n};\n\nexports.peekBytes = peekBytes;\n\nvar readString = function readString(length) {\n  return function (stream) {\n    return Array.from(readBytes(length)(stream)).map(function (value) {\n      return String.fromCharCode(value);\n    }).join('');\n  };\n};\n\nexports.readString = readString;\n\nvar readUnsigned = function readUnsigned(littleEndian) {\n  return function (stream) {\n    var bytes = readBytes(2)(stream);\n    return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];\n  };\n};\n\nexports.readUnsigned = readUnsigned;\n\nvar readArray = function readArray(byteSize, totalOrFunc) {\n  return function (stream, result, parent) {\n    var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;\n    var parser = readBytes(byteSize);\n    var arr = new Array(total);\n\n    for (var i = 0; i < total; i++) {\n      arr[i] = parser(stream);\n    }\n\n    return arr;\n  };\n};\n\nexports.readArray = readArray;\n\nvar subBitsTotal = function subBitsTotal(bits, startIndex, length) {\n  var result = 0;\n\n  for (var i = 0; i < length; i++) {\n    result += bits[startIndex + i] && Math.pow(2, length - i - 1);\n  }\n\n  return result;\n};\n\nvar readBits = function readBits(schema) {\n  return function (stream) {\n    var _byte = readByte()(stream); // convert the byte to bit array\n\n\n    var bits = new Array(8);\n\n    for (var i = 0; i < 8; i++) {\n      bits[7 - i] = !!(_byte & 1 << i);\n    } // convert the bit array to values based on the schema\n\n\n    return Object.keys(schema).reduce(function (res, key) {\n      var def = schema[key];\n\n      if (def.length) {\n        res[key] = subBitsTotal(bits, def.index, def.length);\n      } else {\n        res[key] = bits[def.index];\n      }\n\n      return res;\n    }, {});\n  };\n};\n\nexports.readBits = readBits;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = require(\"../\");\n\nvar _uint = require(\"../parsers/uint8\");\n\n// a set of 0x00 terminated subblocks\nvar subBlocksSchema = {\n  blocks: function blocks(stream) {\n    var terminator = 0x00;\n    var chunks = [];\n    var streamSize = stream.data.length;\n    var total = 0;\n\n    for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {\n      // size becomes undefined for some case when file is corrupted and  terminator is not proper \n      // null check to avoid recursion\n      if (!size) break; // catch corrupted files with no terminator\n\n      if (stream.pos + size >= streamSize) {\n        var availableSize = streamSize - stream.pos;\n        chunks.push((0, _uint.readBytes)(availableSize)(stream));\n        total += availableSize;\n        break;\n      }\n\n      chunks.push((0, _uint.readBytes)(size)(stream));\n      total += size;\n    }\n\n    var result = new Uint8Array(total);\n    var offset = 0;\n\n    for (var i = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset);\n      offset += chunks[i].length;\n    }\n\n    return result;\n  }\n}; // global control extension\n\nvar gceSchema = (0, _.conditional)({\n  gce: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    byteSize: (0, _uint.readByte)()\n  }, {\n    extras: (0, _uint.readBits)({\n      future: {\n        index: 0,\n        length: 3\n      },\n      disposal: {\n        index: 3,\n        length: 3\n      },\n      userInput: {\n        index: 6\n      },\n      transparentColorGiven: {\n        index: 7\n      }\n    })\n  }, {\n    delay: (0, _uint.readUnsigned)(true)\n  }, {\n    transparentColorIndex: (0, _uint.readByte)()\n  }, {\n    terminator: (0, _uint.readByte)()\n  }]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xf9;\n}); // image pipeline block\n\nvar imageSchema = (0, _.conditional)({\n  image: [{\n    code: (0, _uint.readByte)()\n  }, {\n    descriptor: [{\n      left: (0, _uint.readUnsigned)(true)\n    }, {\n      top: (0, _uint.readUnsigned)(true)\n    }, {\n      width: (0, _uint.readUnsigned)(true)\n    }, {\n      height: (0, _uint.readUnsigned)(true)\n    }, {\n      lct: (0, _uint.readBits)({\n        exists: {\n          index: 0\n        },\n        interlaced: {\n          index: 1\n        },\n        sort: {\n          index: 2\n        },\n        future: {\n          index: 3,\n          length: 2\n        },\n        size: {\n          index: 5,\n          length: 3\n        }\n      })\n    }]\n  }, (0, _.conditional)({\n    lct: (0, _uint.readArray)(3, function (stream, result, parent) {\n      return Math.pow(2, parent.descriptor.lct.size + 1);\n    })\n  }, function (stream, result, parent) {\n    return parent.descriptor.lct.exists;\n  }), {\n    data: [{\n      minCodeSize: (0, _uint.readByte)()\n    }, subBlocksSchema]\n  }]\n}, function (stream) {\n  return (0, _uint.peekByte)()(stream) === 0x2c;\n}); // plain text block\n\nvar textSchema = (0, _.conditional)({\n  text: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    preData: function preData(stream, result, parent) {\n      return (0, _uint.readBytes)(parent.text.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0x01;\n}); // application block\n\nvar applicationSchema = (0, _.conditional)({\n  application: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    id: function id(stream, result, parent) {\n      return (0, _uint.readString)(parent.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xff;\n}); // comment block\n\nvar commentSchema = (0, _.conditional)({\n  comment: [{\n    codes: (0, _uint.readBytes)(2)\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xfe;\n});\nvar schema = [{\n  header: [{\n    signature: (0, _uint.readString)(3)\n  }, {\n    version: (0, _uint.readString)(3)\n  }]\n}, {\n  lsd: [{\n    width: (0, _uint.readUnsigned)(true)\n  }, {\n    height: (0, _uint.readUnsigned)(true)\n  }, {\n    gct: (0, _uint.readBits)({\n      exists: {\n        index: 0\n      },\n      resolution: {\n        index: 1,\n        length: 3\n      },\n      sort: {\n        index: 4\n      },\n      size: {\n        index: 5,\n        length: 3\n      }\n    })\n  }, {\n    backgroundColorIndex: (0, _uint.readByte)()\n  }, {\n    pixelAspectRatio: (0, _uint.readByte)()\n  }]\n}, (0, _.conditional)({\n  gct: (0, _uint.readArray)(3, function (stream, result) {\n    return Math.pow(2, result.lsd.gct.size + 1);\n  })\n}, function (stream, result) {\n  return result.lsd.gct.exists;\n}), // content frames\n{\n  frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {\n    var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence\n    // of an ext or image block to avoid infinite loops\n    //var terminator = 0x3B;\n    //return nextCode !== terminator;\n\n    return nextCode === 0x21 || nextCode === 0x2c;\n  })\n}];\nvar _default = schema;\nexports[\"default\"] = _default;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deinterlace = void 0;\n\n/**\r\n * Deinterlace function from https://github.com/shachaf/jsgif\r\n */\nvar deinterlace = function deinterlace(pixels, width) {\n  var newPixels = new Array(pixels.length);\n  var rows = pixels.length / width;\n\n  var cpRow = function cpRow(toRow, fromRow) {\n    var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\n  }; // See appendix E.\n\n\n  var offsets = [0, 4, 2, 1];\n  var steps = [8, 8, 4, 2];\n  var fromRow = 0;\n\n  for (var pass = 0; pass < 4; pass++) {\n    for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\n      cpRow(toRow, fromRow);\n      fromRow++;\n    }\n  }\n\n  return newPixels;\n};\n\nexports.deinterlace = deinterlace;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lzw = void 0;\n\n/**\r\n * javascript port of java LZW decompression\r\n * Original java author url: https://gist.github.com/devunwired/4479231\r\n */\nvar lzw = function lzw(minCodeSize, data, pixelCount) {\n  var MAX_STACK_SIZE = 4096;\n  var nullCode = -1;\n  var npix = pixelCount;\n  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n  var dstPixels = new Array(pixelCount);\n  var prefix = new Array(MAX_STACK_SIZE);\n  var suffix = new Array(MAX_STACK_SIZE);\n  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.\n\n  data_size = minCodeSize;\n  clear = 1 << data_size;\n  end_of_information = clear + 1;\n  available = clear + 2;\n  old_code = nullCode;\n  code_size = data_size + 1;\n  code_mask = (1 << code_size) - 1;\n\n  for (code = 0; code < clear; code++) {\n    prefix[code] = 0;\n    suffix[code] = code;\n  } // Decode GIF pixel stream.\n\n\n  var datum, bits, count, first, top, pi, bi;\n  datum = bits = count = first = top = pi = bi = 0;\n\n  for (i = 0; i < npix;) {\n    if (top === 0) {\n      if (bits < code_size) {\n        // get the next byte\n        datum += data[bi] << bits;\n        bits += 8;\n        bi++;\n        continue;\n      } // Get the next code.\n\n\n      code = datum & code_mask;\n      datum >>= code_size;\n      bits -= code_size; // Interpret the code\n\n      if (code > available || code == end_of_information) {\n        break;\n      }\n\n      if (code == clear) {\n        // Reset decoder.\n        code_size = data_size + 1;\n        code_mask = (1 << code_size) - 1;\n        available = clear + 2;\n        old_code = nullCode;\n        continue;\n      }\n\n      if (old_code == nullCode) {\n        pixelStack[top++] = suffix[code];\n        old_code = code;\n        first = code;\n        continue;\n      }\n\n      in_code = code;\n\n      if (code == available) {\n        pixelStack[top++] = first;\n        code = old_code;\n      }\n\n      while (code > clear) {\n        pixelStack[top++] = suffix[code];\n        code = prefix[code];\n      }\n\n      first = suffix[code] & 0xff;\n      pixelStack[top++] = first; // add a new string to the table, but only if space is available\n      // if not, just continue with current table until a clear code is found\n      // (deferred clear code implementation as per GIF spec)\n\n      if (available < MAX_STACK_SIZE) {\n        prefix[available] = old_code;\n        suffix[available] = first;\n        available++;\n\n        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n          code_size++;\n          code_mask += available;\n        }\n      }\n\n      old_code = in_code;\n    } // Pop a pixel off the pixel stack.\n\n\n    top--;\n    dstPixels[pi++] = pixelStack[top];\n    i++;\n  }\n\n  for (i = pi; i < npix; i++) {\n    dstPixels[i] = 0; // clear missing pixels\n  }\n\n  return dstPixels;\n};\n\nexports.lzw = lzw;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompressFrames = exports.decompressFrame = exports.parseGIF = void 0;\n\nvar _gif = _interopRequireDefault(require(\"js-binary-schema-parser/lib/schemas/gif\"));\n\nvar _jsBinarySchemaParser = require(\"js-binary-schema-parser\");\n\nvar _uint = require(\"js-binary-schema-parser/lib/parsers/uint8\");\n\nvar _deinterlace = require(\"./deinterlace\");\n\nvar _lzw = require(\"./lzw\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar parseGIF = function parseGIF(arrayBuffer) {\n  var byteData = new Uint8Array(arrayBuffer);\n  return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif[\"default\"]);\n};\n\nexports.parseGIF = parseGIF;\n\nvar generatePatch = function generatePatch(image) {\n  var totalPixels = image.pixels.length;\n  var patchData = new Uint8ClampedArray(totalPixels * 4);\n\n  for (var i = 0; i < totalPixels; i++) {\n    var pos = i * 4;\n    var colorIndex = image.pixels[i];\n    var color = image.colorTable[colorIndex] || [0, 0, 0];\n    patchData[pos] = color[0];\n    patchData[pos + 1] = color[1];\n    patchData[pos + 2] = color[2];\n    patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;\n  }\n\n  return patchData;\n};\n\nvar decompressFrame = function decompressFrame(frame, gct, buildImagePatch) {\n  if (!frame.image) {\n    console.warn('gif frame does not have associated image.');\n    return;\n  }\n\n  var image = frame.image; // get the number of pixels\n\n  var totalPixels = image.descriptor.width * image.descriptor.height; // do lzw decompression\n\n  var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels); // deal with interlacing if necessary\n\n  if (image.descriptor.lct.interlaced) {\n    pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);\n  }\n\n  var resultImage = {\n    pixels: pixels,\n    dims: {\n      top: frame.image.descriptor.top,\n      left: frame.image.descriptor.left,\n      width: frame.image.descriptor.width,\n      height: frame.image.descriptor.height\n    }\n  }; // color table\n\n  if (image.descriptor.lct && image.descriptor.lct.exists) {\n    resultImage.colorTable = image.lct;\n  } else {\n    resultImage.colorTable = gct;\n  } // add per frame relevant gce information\n\n\n  if (frame.gce) {\n    resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms\n\n    resultImage.disposalType = frame.gce.extras.disposal; // transparency\n\n    if (frame.gce.extras.transparentColorGiven) {\n      resultImage.transparentIndex = frame.gce.transparentColorIndex;\n    }\n  } // create canvas usable imagedata if desired\n\n\n  if (buildImagePatch) {\n    resultImage.patch = generatePatch(resultImage);\n  }\n\n  return resultImage;\n};\n\nexports.decompressFrame = decompressFrame;\n\nvar decompressFrames = function decompressFrames(parsedGif, buildImagePatches) {\n  return parsedGif.frames.filter(function (f) {\n    return f.image;\n  }).map(function (f) {\n    return decompressFrame(f, parsedGif.gct, buildImagePatches);\n  });\n};\n\nexports.decompressFrames = decompressFrames;"],
  "mappings": "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",
  "names": ["parse", "conditional", "loop", "buildStream", "readByte", "peekByte", "readBytes", "peekBytes", "readString", "readUnsigned", "readArray", "subBitsTotal", "readBits", "deinterlace", "cpRow", "toRow", "fromRow", "lzw", "require_lib", "parseGIF", "generatePatch", "decompressFrame", "decompressFrames"]
}
